# static const volatile
Static：静态函数、静态变量、静态类成员
    声明为static的局部变量的生存期不再是当前作用域，而是整个程序的生存期。
    static全局变量和函数，其作用域为当前cpp文件，其它的cpp文件不能访问该变量和函数。如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量。
    普通的全局变量和函数，其作用域为整个程序或项目，外部文件（其它cpp文件）可以通过extern关键字访问该变量和函数。一般不提倡这种用法，如果要在多个cpp文件间共享数据，应该将数据声明为extern类型。
    static函数的好处是不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名。
    static应用场景:
    当某个方法的调用频率非常高, 而该方法中更有些变量的值是固定不变的
    那么这个时候就可以使用static来修饰该变量, 让该变量只开辟一次存储空间
    这样可以提高程序的效率和性能
Const：const变量，const指针、const函数
    const作用:
          1.用于修饰右边变量(基本变量,指针变量)
          2.被const修饰变量只读(普通的变量是可读可写的)
            const 只能修饰输入参数：如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。
    const与宏区别:
        1.编译时刻: 宏:预编译 const:编译
        2.编译检查:  宏不会做编译检查 const会
        3.宏好处: 宏可以定义函数和方法 const不行
        4.宏坏处: 大量使用宏,会导致预编译时间过长
    开发中const使用场景
    1.const替换宏,宏:在开发中将常用字符串或者基本数据定义成宏 -> const
    2.修饰方法的参数,让方法的参数只读(即用const直接修饰方法的参数参数)
    开发中如果使用全局变量,最容易导致冲突
    开发规范:只要定义全局变量,都不能在自己的类中定义,一般开发中,我们会搞一个公用文件去定义全局变量
Volatile：多线程共享变量
    volatile告诉编译器不要持有变量的临时拷贝
    编译器对访问该变量的代码不再进行优化，从而可以提供对特殊地址的稳定访问。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
Typeof：获取类型值


# 多线程
Python 的线程更适用于处理 I/O 和其他需要并发行的阻塞操作（比如等待 I/O、等待从数据库获取数据等等），而不是需要多处理器行的计算密集型任务。幸运的是,爬虫大部分时间在网络交互上，所以可以使用多线程来编写爬虫。
scrapy的并发并不是采用多线程来实现，它是一个twisted应用，通过异步非阻塞来达到并发。
Python中当你想要提高执行效率，大部分开发者是通过编写多进程来提高运行效率，使用multiprocessing进行并行编程，当然，你可以编写多进程爬虫来爬取信息，缺点是每个进程都会有自己的内存，数据多的话，内存会吃不消。
使用线程有什么缺点呢，缺点就是你在编写多线程代码时候，要注意死锁的问题、阻塞的问题、以及需要注意多线程之间通信的问题(避免多个线程执行同一个任务)。
python中多进程与多线程有太多相似的地方，例如它们方法大体相同，甚至可以说完全相同，为什么使用多进程呢？当你想提高cpu密集型任务的效率时，你便可以使用多进程来改善这种情况。

# 堆与栈的区别
栈内存存储的是局部变量而堆内存是实体，栈内存的更新速度高于堆内存，栈内存的生命周期一结束就会被释放而堆内存会被垃圾回收机制不定时回收

# 继承、重写、重载、多态（多种形态） 虚函数、接口
多态（父类使用子类的方法）意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
public class Brass extends Instrument {
Instrument instrument = new Brass();//多态
Brass brass = new Brass();//继承
虚函数声明如下：virtual ReturnType FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错。
纯虚函数声明如下： virtual void funtion1()=0;
虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
继承（子类使用父类的方法）：class Rectangle: public Shape
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
重写（子类与父类）：如果在子类中定义的一个方法，其名称、返回类型及参数列表正好与父类中某个方法的名称、返回类型及参数列表相匹配，那么可以说，子类的方法重写了父类的方法。
重载（类内部）运算符和重载函数：
重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。不能仅通过返回类型的不同来重载函数。
// 重载 + 运算符，用于把两个 Box 对象相加
    Box operator+(const Box& b)
    {
        Box box;
        box.length = this->length + b.length;
        box.breadth = this->breadth + b.breadth;
        box.height = this->height + b.height;
        return box;
    }
接口：接口把方法的特征和实现分割开来。它本身没有任何实现，不涉及表象，只描述public行为，所以接口比抽象类更抽象化。但是接口不是类，所以不能被实例化。

将构造函数和析构函数声明为私有 private 函数，该函数就不可被继承。


# 如何避免同一头文件的多次include
#ifndef … 或者#pragma once


# 进程间通信方式
管道、信号、消息队列、共享内存、socket
管道（Pipe,mkfifo p_in p_out）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
信号（Signal, kill -9）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。 
报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。


# HTTP 的 Session
由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。
访问*.html的静态资源因为不会被编译为Servlet，也就不涉及session的问题。
客户端接着请求本应用中其他资源的时候，会自动在请求头requestHeader上添加：Cookie:JSESSIONID=客户端第一次拿到的session ID。客户端浏览器只是拿到的是session ID，而这个对于浏览器操作的人来说，是不可见的，并且用户也无需关心自己处于哪个会话过程中。
服务器端在接到请求时候，就会收到session ID，并根据ID在内存中找到之前创建的session对象，提供给请求使用。
session存放在哪里：服务器端的内存中。不过session可以通过特殊的方式做持久化管理。session是一个容器，可以存放会话过程中的任何对象。
一个会话只能有一个session对象，对session来说是只认id不认人。
session不会因为浏览器的关闭而删除吗。同一客户端机器多次请求同一个资源，session一样吗？一般来说，每次请求都会新创建一个session。







# socket 高并发
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。
粘包：发送方发送两个字符串”hello”+”world”，接收方却一次性接收到了”helloworld”。只有TCP有粘包现象，UDP永远不会粘包。是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。分包：发送方发送字符串”helloworld”，接收方却接收到了两个字符串”hello”和”world”。
如何解决粘包问题：为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据

不要轻信任何人所说的异步系统一定更快的言论。异步几乎一定意味着更高的并发，但是往往并发过了头了。
进行一次系统调用并将数据从内核空间移动到用户空间比在进程空间内移动内存要更加昂贵。这就是为什么只执行必需的系统调用非常重要（但是也不能过少）。
